<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Seri Analiz & Tahmin</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.1/chart.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
<style>
@import url('https://fonts.googleapis.com/css2?family=Space+Mono:ital,wght@0,400;0,700;1,400&family=Bebas+Neue&display=swap');

:root{
  --bg:#f4efe4; --paper:#faf6ed; --ink:#1c1710; --ink2:#3a3228; --ink3:#6e6050;
  --rule:#d6c9b4; --red:#b83232; --blue:#1a5c8a; --green:#1f7a45;
  --amber:#c07a00; --purple:#6b3fa0;
}
*{margin:0;padding:0;box-sizing:border-box;}
body{background:var(--bg);color:var(--ink);font-family:'Space Mono',monospace;min-height:100vh;}
body::before{content:'';position:fixed;inset:0;pointer-events:none;z-index:0;
  background-image:repeating-linear-gradient(transparent,transparent 27px,rgba(180,158,130,.22) 27px,rgba(180,158,130,.22) 28px);}
.wrap{position:relative;z-index:1;max-width:1320px;margin:0 auto;padding:28px 22px 80px;}

/* HEADER */
header{border-bottom:3px solid var(--ink);padding-bottom:18px;margin-bottom:30px;}
.eyebrow{font-size:10px;letter-spacing:4px;color:var(--ink3);text-transform:uppercase;margin-bottom:4px;}
h1{font-family:'Bebas Neue',sans-serif;font-size:clamp(34px,5.5vw,66px);letter-spacing:3px;line-height:.95;}
h1 em{color:var(--blue);font-style:normal;} h1 strong{color:var(--red);}
.sub{margin-top:8px;font-size:11px;color:var(--ink3);line-height:1.85;max-width:600px;}

/* PANELS */
.entry-grid{display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-bottom:22px;}
@media(max-width:820px){.entry-grid{grid-template-columns:1fr;}}
.panel{background:var(--paper);border:2px solid var(--ink);padding:20px 20px 16px;position:relative;margin-top:14px;}
.panel::before{content:attr(data-lbl);position:absolute;top:-12px;left:12px;
  background:var(--paper);padding:0 8px;font-size:10px;letter-spacing:3px;
  text-transform:uppercase;font-weight:700;border:2px solid var(--ink);}
.panel.blue-lbl::before{color:var(--blue);border-color:var(--blue);}
.panel.red-lbl::before{color:var(--red);border-color:var(--red);}
.panel-hint{font-size:10px;color:var(--ink3);margin-top:7px;line-height:1.75;}
.panel-hint b{color:var(--blue);}

textarea{width:100%;height:110px;background:transparent;border:1px solid var(--rule);
  color:var(--ink);font-family:'Space Mono',monospace;font-size:12px;
  padding:9px 10px;resize:vertical;outline:none;line-height:1.75;}
textarea:focus{border-color:var(--ink);}

/* SET INPUT */
#setInput{width:100%;background:transparent;border:1px solid var(--rule);
  color:var(--ink);font-family:'Space Mono',monospace;font-size:13px;
  padding:9px 10px;outline:none;margin-bottom:8px;}
#setInput:focus{border-color:var(--blue);}
#setPreview{display:flex;flex-wrap:wrap;gap:5px;min-height:24px;margin-bottom:6px;}
.tag{display:inline-flex;align-items:center;gap:4px;
  background:rgba(26,92,138,.1);border:1px solid rgba(26,92,138,.35);
  color:var(--blue);padding:3px 9px;font-size:11px;font-weight:700;}

/* CONTROLS */
.ctrl-row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;
  margin-bottom:22px;padding:14px 18px;background:var(--paper);border:2px solid var(--ink);}
.ctrl{display:flex;flex-direction:column;gap:4px;}
.ctrl label{font-size:9px;letter-spacing:2px;text-transform:uppercase;color:var(--ink3);}
.ctrl .v{font-size:14px;font-weight:700;color:var(--ink);}
.ctrl input[type=range]{-webkit-appearance:none;width:110px;height:3px;background:var(--rule);outline:none;cursor:pointer;}
.ctrl input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;width:13px;height:13px;background:var(--ink);border-radius:50%;cursor:pointer;}
.ctrl select{background:transparent;border:1px solid var(--rule);color:var(--ink);
  padding:5px 8px;font-family:'Space Mono',monospace;font-size:11px;outline:none;cursor:pointer;}

.btn{padding:9px 18px;background:var(--ink);color:var(--bg);border:2px solid var(--ink);
  font-family:'Space Mono',monospace;font-size:11px;letter-spacing:2px;text-transform:uppercase;
  cursor:pointer;transition:all .15s;white-space:nowrap;}
.btn:hover{background:transparent;color:var(--ink);}
.btn.b-green{background:var(--green);border-color:var(--green);}
.btn.b-green:hover{background:transparent;color:var(--green);}
.btn.b-red{background:var(--red);border-color:var(--red);}
.btn.b-red:hover{background:transparent;color:var(--red);}
.btn:disabled{opacity:.38;cursor:not-allowed;}

/* STAT BAR */
.stat-bar{display:grid;grid-template-columns:repeat(auto-fit,minmax(110px,1fr));
  margin-bottom:22px;border:2px solid var(--ink);overflow:hidden;}
.si{padding:11px 14px;background:var(--paper);border-right:1px solid var(--rule);}
.si:last-child{border-right:none;}
.si-lbl{font-size:9px;letter-spacing:2px;text-transform:uppercase;color:var(--ink3);margin-bottom:3px;}
.si-val{font-size:18px;font-weight:700;color:var(--ink);}
.si-val.ok{color:var(--green);} .si-val.warn{color:var(--amber);} .si-val.err{color:var(--red);}
.si-sub{font-size:9px;color:var(--ink3);margin-top:2px;}

/* CHART */
.chart-card{background:var(--paper);border:2px solid var(--ink);padding:18px 20px;margin-bottom:20px;}
.chart-card.fullscreen{position:fixed!important;inset:0!important;z-index:9999!important;
  margin:0!important;border:none!important;display:flex;flex-direction:column;
  padding:16px 20px;background:var(--paper)!important;}
.chart-card.fullscreen .chart-wrap{flex:1;height:auto!important;}
.chart-top{display:flex;align-items:center;justify-content:space-between;flex-wrap:wrap;gap:8px;margin-bottom:6px;}
.chart-title-txt{font-family:'Bebas Neue',sans-serif;font-size:20px;letter-spacing:2px;}
.chart-btns{display:flex;gap:5px;}
.cc-btn{background:var(--paper);border:2px solid var(--ink);color:var(--ink);
  font-family:'Space Mono',monospace;font-size:14px;width:30px;height:30px;
  cursor:pointer;display:flex;align-items:center;justify-content:center;
  padding:0;transition:all .12s;line-height:1;}
.cc-btn:hover{background:var(--ink);color:var(--bg);}
.legend{display:flex;gap:16px;flex-wrap:wrap;font-size:10px;margin-bottom:10px;}
.leg{display:flex;align-items:center;gap:5px;}
.leg-line{width:22px;height:3px;border-radius:1px;}
.chart-wrap{position:relative;width:100%;height:340px;}
.chart-wrap canvas{position:absolute;inset:0;width:100%!important;height:100%!important;}

/* PROGRESS */
.prog-wrap{display:none;background:var(--paper);border:2px solid var(--ink);
  padding:14px 18px;margin-bottom:18px;}
.prog-lbl{font-size:10px;letter-spacing:2px;text-transform:uppercase;color:var(--ink3);margin-bottom:6px;}
.prog-outer{width:100%;height:5px;background:var(--rule);}
.prog-inner{height:100%;background:var(--green);transition:width .1s;}
.prog-txt{font-size:13px;font-weight:700;margin-top:5px;}

/* RESULTS */
.results-grid{display:grid;grid-template-columns:1fr 1fr;gap:18px;margin-bottom:18px;}
@media(max-width:700px){.results-grid{grid-template-columns:1fr;}}
.rc{background:var(--paper);border:2px solid var(--ink);padding:18px;}
.rc-title{font-family:'Bebas Neue',sans-serif;font-size:17px;letter-spacing:2px;
  border-bottom:1px solid var(--rule);padding-bottom:7px;margin-bottom:12px;}
.fr{display:flex;justify-content:space-between;align-items:baseline;
  padding:5px 0;border-bottom:1px dotted var(--rule);font-size:11px;}
.fr:last-child{border-bottom:none;}
.fr-l{color:var(--ink3);} .fr-r{font-weight:700;}
.fr-r.ok{color:var(--green);} .fr-r.warn{color:var(--amber);} .fr-r.err{color:var(--red);}

/* 2D PROBABILITY TABLE */
.prob2d-wrap{overflow-x:auto;}
.prob2d{border-collapse:collapse;font-size:11px;width:100%;}
.prob2d th{
  padding:7px 11px;background:var(--ink);color:var(--bg);
  font-size:9px;letter-spacing:2px;text-transform:uppercase;
  border:1px solid var(--ink2);white-space:nowrap;text-align:center;}
.prob2d th.rh{background:var(--ink2);}
.prob2d td{
  padding:6px 10px;border:1px solid var(--rule);
  text-align:center;white-space:nowrap;font-size:12px;font-weight:700;}
.prob2d tr:hover td{filter:brightness(.97);}
.prob2d td.step-hdr{
  background:var(--paper);color:var(--ink3);
  font-size:10px;letter-spacing:1px;font-weight:700;text-align:left;}
.prob2d td.best{outline:2px solid var(--green);outline-offset:-2px;}
.prob2d td.best-txt{font-weight:700;color:var(--green);background:rgba(31,122,69,.06);}

.info-box{background:var(--paper);border-left:4px solid var(--ink);
  padding:14px 18px;margin-bottom:18px;font-size:11px;line-height:1.9;color:var(--ink2);}
</style>
</head>
<body>
<div class="wrap">

<header>
  <div class="eyebrow">// Adım Kümesi · Seri Analiz · 2B Olasılık Tahmini</div>
  <h1><em>SERİ</em><br><strong>TAHMİN</strong></h1>
  <p class="sub">
    İzin verilen değerleri virgülle yaz · Veriyi yapıştır<br>
    5 yöntem · 2B olasılık ısı tablosu · Zoom/Pan/Tam Ekran
  </p>
</header>

<div class="entry-grid">

  <div class="panel blue-lbl" data-lbl="adım kümesi">
    <input id="setInput" placeholder="Örnek:  1, 2, 3   veya   3, 3.2, 3.4, 3.6"
      oninput="parseSetInput()" autocomplete="off">
    <div id="setPreview"></div>
    <div class="panel-hint">
      Virgülle ayırarak direkt yaz. <b>Örnek: 1, 2, 3</b><br>
      Veri serisi bu değerlerden oluşmalıdır.
    </div>
  </div>

  <div class="panel red-lbl" data-lbl="veri serisi">
    <textarea id="seriesInput"
      placeholder="3,3,3.2,3.2,3.4,3.4,3.2,3,3,3.2,3.4,3.6,3.4,3.2,3,3,3.2&#10;&#10;Virgül, noktalı virgül veya yeni satır ile ayırın."></textarea>
    <div class="panel-hint">Ham değerler — kümülatif değil.</div>
  </div>

</div>

<!-- CONTROLS -->
<div class="ctrl-row">
  <div class="ctrl">
    <label>Tahmin Adımı</label>
    <span class="v" id="vN">8</span>
    <input type="range" id="rN" min="1" max="24" value="8"
      oninput="document.getElementById('vN').textContent=this.value">
  </div>
  <div class="ctrl">
    <label>Yöntem</label>
    <select id="method">
      <option value="mc">MC Markov Zinciri</option>
      <option value="arima">ARIMA-lite AR(p)</option>
      <option value="holt">Holt Exp. Smoothing</option>
      <option value="nbwin">Naive Bayes (Pencere)</option>
      <option value="kalman">Kalman Filter</option>
      <option value="gp">Gaussian Process (Matérn 5/2)</option>
      <option value="particle">Particle Filter</option>
      <option value="combined" selected>Ensemble (7 Yöntem)</option>
    </select>
  </div>
  <div class="ctrl">
    <label>Simülasyon</label>
    <span class="v" id="vMC">2000</span>
    <input type="range" id="rMC" min="500" max="10000" step="500" value="2000"
      oninput="document.getElementById('vMC').textContent=this.value">
  </div>
  <div class="ctrl">
    <label>Güven Bandı</label>
    <select id="bandConf">
      <option value="0.8">%80</option>
      <option value="0.9" selected>%90</option>
      <option value="0.95">%95</option>
    </select>
  </div>
  <div style="flex:1"></div>
  <button class="btn b-green" onclick="runAnalysis()">▶ ANALİZ ET</button>
  <button class="btn b-red" onclick="loadExample()">ÖRNEK</button>
</div>

<!-- STAT BAR -->
<div class="stat-bar">
  <div class="si"><div class="si-lbl">Veri Uzunluğu</div><div class="si-val" id="stLen">—</div></div>
  <div class="si"><div class="si-lbl">Küme Boyutu</div><div class="si-val" id="stSetN">—</div></div>
  <div class="si"><div class="si-lbl">Geçersiz</div><div class="si-val" id="stBad">—</div></div>
  <div class="si"><div class="si-lbl">Ortalama</div><div class="si-val" id="stMean">—</div></div>
  <div class="si"><div class="si-lbl">Std Dev</div><div class="si-val" id="stStd">—</div></div>
  <div class="si"><div class="si-lbl">ACF(1)</div><div class="si-val" id="stAcf">—</div></div>
  <div class="si"><div class="si-lbl">Trend</div><div class="si-val" id="stTrend">—</div></div>
  <div class="si"><div class="si-lbl">Entropi</div><div class="si-val" id="stEnt">—</div><div class="si-sub">dağılım belirsizliği</div></div>
</div>

<!-- CHART -->
<div class="chart-card" id="chartCard">
  <div class="chart-top">
    <div class="chart-title-txt">VERİ + TAHMİN</div>
    <div class="chart-btns">
      <button class="cc-btn" onclick="zoomIn()">＋</button>
      <button class="cc-btn" onclick="zoomOut()">－</button>
      <button class="cc-btn" onclick="resetZoom()">⊙</button>
      <button class="cc-btn" id="fsBtn" onclick="toggleFS()">⛶</button>
    </div>
  </div>
  <div class="legend">
    <div class="leg"><div class="leg-line" style="background:var(--blue)"></div>Gözlem</div>
    <div class="leg"><div class="leg-line" style="background:var(--green);border-top:2px dashed var(--green);height:0"></div>Median</div>
    <div class="leg"><div class="leg-line" style="height:10px;width:22px;background:rgba(31,122,69,.10);border:1px solid rgba(31,122,69,.3)"></div>Güven bandı</div>
    <div class="leg"><div class="leg-line" style="background:var(--red);border-top:2px dotted var(--red);height:0"></div>Geçersiz</div>
    <span style="font-size:9px;color:var(--ink3);margin-left:auto;">scroll/pinch zoom · sürükle pan · ESC çıkış</span>
  </div>
  <div class="chart-wrap"><canvas id="mainChart"></canvas></div>
</div>

<!-- PROGRESS -->
<div class="prog-wrap" id="progWrap">
  <div class="prog-lbl" id="progLbl">Hesaplanıyor…</div>
  <div class="prog-outer"><div class="prog-inner" id="progBar" style="width:0%"></div></div>
  <div class="prog-txt" id="progTxt">0%</div>
</div>

<!-- RESULTS -->
<div id="resultsArea" style="display:none">

  <div class="results-grid">
    <div class="rc">
      <div class="rc-title">ANALİZ BULGULARI</div>
      <div id="findings"></div>
    </div>
    <div class="rc">
      <div class="rc-title">TAHMİN ÖZETİ</div>
      <div id="predSummary"></div>
    </div>
  </div>

  <!-- 2D TABLE -->
  <div class="rc" style="margin-bottom:18px;">
    <div class="rc-title">2B OLASILIK TABLOSU
      <span style="font-size:11px;font-family:'Space Mono',monospace;font-weight:400;color:var(--ink3);margin-left:8px;">
        Satır = adım · Sütun = değer · Hücre = % olasılık
      </span>
    </div>
    <div class="prob2d-wrap" id="prob2dWrap"></div>
  </div>

  <div class="info-box" id="infoBox"></div>
</div>

</div>

<script>
// ════════ STATE ════════
let allowedSet=[], seriesData=[], mainChart=null;

// ════════ SET INPUT ════════
function parseSetInput(){
  const raw=document.getElementById('setInput').value;
  const vals=raw.split(/[,;\s]+/).map(v=>parseFloat(v)).filter(v=>!isNaN(v));
  allowedSet=[...new Set(vals)].sort((a,b)=>a-b);
  document.getElementById('setPreview').innerHTML=
    allowedSet.map(v=>`<span class="tag">${v}</span>`).join('');
  document.getElementById('stSetN').textContent=allowedSet.length||'—';
}

function parseSeries(){
  return document.getElementById('seriesInput').value
    .split(/[\n,;]+/).map(v=>parseFloat(v.trim())).filter(v=>!isNaN(v));
}

// ════════ MATH ════════
const mean=a=>a.reduce((s,v)=>s+v,0)/a.length;
const std=a=>{ const m=mean(a); return Math.sqrt(a.reduce((s,v)=>s+(v-m)**2,0)/a.length); };
function acf1(a){
  const m=mean(a),n=a.length;
  const num=a.slice(1).reduce((s,v,i)=>s+(v-m)*(a[i]-m),0);
  const den=a.reduce((s,v)=>s+(v-m)**2,0);
  return den===0?0:num/den;
}
function pct(a,p){
  const s=[...a].sort((x,y)=>x-y);
  return s[Math.min(s.length-1,Math.max(0,Math.floor(p*(s.length-1))))];
}
function linTrend(a){
  const n=a.length,xs=Array.from({length:n},(_,i)=>i);
  const mx=mean(xs),my=mean(a);
  const num=xs.reduce((s,x,i)=>s+(x-mx)*(a[i]-my),0);
  const den=xs.reduce((s,x)=>s+(x-mx)**2,0);
  return den===0?0:num/den;
}
function entropy(data,set){
  const cnt={};
  set.forEach(v=>{cnt[v]=0;});
  data.forEach(v=>{const k=snapToSet(v,set);cnt[k]=(cnt[k]||0)+1;});
  let h=0;
  Object.values(cnt).forEach(c=>{const p=c/data.length;if(p>0)h-=p*Math.log2(p);});
  return h;
}
function gaussRand(){
  let u=0,v=0;
  while(!u)u=Math.random(); while(!v)v=Math.random();
  return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
}
function snapToSet(v,set){
  if(!set.length)return v;
  return set.reduce((b,x)=>Math.abs(x-v)<Math.abs(b-v)?x:b,set[0]);
}
function sleep(ms){return new Promise(r=>setTimeout(r,ms));}
function setP(p,lbl,txt){
  document.getElementById('progBar').style.width=p+'%';
  document.getElementById('progTxt').textContent=txt||Math.round(p)+'%';
  if(lbl)document.getElementById('progLbl').textContent=lbl;
}

// ════════ TRANSITION MATRIX ════════
function buildTrans(data,set){
  const n=set.length;
  const idx=v=>set.findIndex(x=>Math.abs(x-v)<1e-9);
  const T=Array.from({length:n},()=>Array(n).fill(0.1)); // Laplace
  for(let i=1;i<data.length;i++){
    const fi=idx(data[i-1]),ti=idx(data[i]);
    if(fi>=0&&ti>=0)T[fi][ti]++;
  }
  return T.map(row=>{ const s=row.reduce((a,b)=>a+b,0); return row.map(v=>v/s); });
}

// ════════ METHOD 1: MC Markov ════════
function mcPredict(data,steps,set,T){
  if(!set.length){
    const s=std(data),m=mean(data),a=acf1(data);
    let last=data[data.length-1];
    return Array.from({length:steps},()=>{
      last=last*a+m*(1-Math.abs(a))+s*gaussRand()*(1-Math.abs(a)); return last;});
  }
  const idx=v=>set.findIndex(x=>Math.abs(x-v)<1e-9);
  let cur=idx(data[data.length-1]); if(cur<0)cur=Math.floor(set.length/2);
  return Array.from({length:steps},()=>{
    const row=T[cur],r=Math.random();
    let cum=0;
    for(let j=0;j<set.length;j++){cum+=row[j];if(r<=cum){cur=j;break;}}
    return set[cur];
  });
}

// ════════ METHOD 2: AR(p) ════════
function fitAR(data,p=4){
  const n=data.length; if(n<=p)return Array(p).fill(0);
  const m=mean(data);
  const c=Array.from({length:p+1},(_,k)=>{
    let s=0;for(let i=k;i<n;i++)s+=(data[i]-m)*(data[i-k]-m);return s/(n-k);});
  let phi=[c[1]/(c[0]||1e-10)];
  let V=c[0]*(1-phi[0]**2);
  for(let lag=2;lag<=p;lag++){
    const num=c[lag]-phi.reduce((s,ph,j)=>s+ph*(c[lag-1-j]||0),0);
    const kk=num/(V||1e-10);
    const phi2=[...phi.map((ph,j)=>ph-kk*(phi[lag-2-j]||0))];
    phi2.push(kk); phi=phi2; V*=(1-kk**2);
    if(isNaN(V)||V<=0)break;
  }
  return phi;
}
function arPredict(data,phi,steps,nStd,set){
  const m=mean(data);
  let hist=[...data].map(v=>v-m);
  return Array.from({length:steps},()=>{
    let pred=phi.reduce((sum,ph,j)=>sum+ph*(hist[hist.length-1-j]||0),0)+m+nStd*gaussRand();
    if(set.length)pred=snapToSet(pred,set);
    hist.push(pred-m); return pred;
  });
}

// ════════ METHOD 3: Holt Exponential Smoothing ════════
function holtPredict(data,steps,set,nStd){
  const alpha=0.3,beta=0.1;
  let lv=data[0],tr=(data[data.length-1]-data[0])/(data.length-1||1);
  for(let i=1;i<data.length;i++){
    const lp=lv,tp=tr;
    lv=alpha*data[i]+(1-alpha)*(lp+tp);
    tr=beta*(lv-lp)+(1-beta)*tp;
  }
  return Array.from({length:steps},(_,s)=>{
    let v=lv+tr*(s+1)+nStd*gaussRand();
    if(set.length)v=snapToSet(v,set); return v;
  });
}

// ════════ METHOD 4: Naive Bayes Sliding Window ════════
function nbWindowPredict(data,steps,set,win=3){
  if(!set.length||data.length<win+1)return mcPredict(data,steps,set,buildTrans(data,set.length?set:[...new Set(data)].sort((a,b)=>a-b)));
  const idx=v=>set.findIndex(x=>Math.abs(x-v)<1e-9);
  const key=w=>w.map(v=>idx(v)).join('-');
  const cnt={};
  for(let i=win;i<data.length;i++){
    const k=key(data.slice(i-win,i)),ni=idx(data[i]);
    if(ni<0)continue;
    if(!cnt[k])cnt[k]=Array(set.length).fill(0.05);
    cnt[k][ni]++;
  }
  let w=[...data.slice(-win)];
  return Array.from({length:steps},()=>{
    const k=key(w);
    const row=cnt[k]||Array(set.length).fill(1);
    const total=row.reduce((a,b)=>a+b,0);
    const r=Math.random()*total;
    let cum=0,chosen=0;
    for(let j=0;j<set.length;j++){cum+=row[j];if(r<=cum){chosen=j;break;}}
    w=[...w.slice(1),set[chosen]]; return set[chosen];
  });
}

// ════════════════════════════════════════════════════════
// METHOD 5: KALMAN FILTER
// Gizli durum: [seviye, trend]. Ölçüm gürültüsü R, süreç
// gürültüsü Q data'dan otomatik tahmin edilir.
// Tahmin aşamasında rastgele süreç gürültüsü eklenerek
// Monte-Carlo tarzı olasılık dağılımı üretilir.
// ════════════════════════════════════════════════════════
function kalmanPredict(data, steps, set, nRep=1) {
  const n = data.length;
  // --- EM-lite: varyans tahminleri ---
  const R = Math.pow(std(data) * 0.4, 2);   // ölçüm gürültüsü
  const Q = Math.pow(std(data) * 0.15, 2);  // süreç gürültüsü
  const Qt = Math.pow(std(data) * 0.05, 2); // trend gürültüsü

  // Durum: x = [seviye, trend]
  // Geçiş: F = [[1,1],[0,1]]
  // Ölçüm: H = [1, 0]
  function kFilter(obs) {
    let xl = obs[0], xt = (obs[1]-obs[0]);
    let Pll=1, Plt=0, Ptt=1;
    for (let i=1; i<obs.length; i++) {
      // Predict
      const xl_ = xl + xt;
      const xt_ = xt;
      const Pll_ = Pll + 2*Plt + Ptt + Q;
      const Plt_ = Plt + Ptt;
      const Ptt_ = Ptt + Qt;
      // Innovation
      const inn = obs[i] - xl_;
      const S   = Pll_ + R;
      // Kalman gain
      const Kl = Pll_ / S;
      const Kt = Plt_ / S;
      // Update
      xl = xl_ + Kl * inn;
      xt = xt_ + Kt * inn;
      Pll = (1-Kl)*Pll_;
      Plt = (1-Kl)*Plt_ - Kl*Ptt_;  // simplified cross-cov
      Ptt = Ptt_ - Kt*Plt_;
    }
    return { xl, xt, Pll, Ptt };
  }

  const { xl, xt, Pll, Ptt } = kFilter(data);
  const paths = [];
  for (let r=0; r<nRep; r++) {
    let lv = xl + gaussRand()*Math.sqrt(Pll);
    let tr = xt + gaussRand()*Math.sqrt(Math.abs(Ptt));
    const path = [];
    for (let s=0; s<steps; s++) {
      lv = lv + tr + gaussRand()*Math.sqrt(Q);
      tr = tr + gaussRand()*Math.sqrt(Qt);
      let v = lv + gaussRand()*Math.sqrt(R);
      if (set.length) v = snapToSet(v, set);
      path.push(v);
    }
    paths.push(path);
  }
  // Return single path (median across reps if nRep>1)
  if (nRep === 1) return paths[0];
  return Array.from({length:steps}, (_,s) => {
    const vals = paths.map(p=>p[s]);
    return pct(vals, 0.5);
  });
}

// ════════════════════════════════════════════════════════
// METHOD 6: GAUSSIAN PROCESS — Matérn 5/2 kernel
//
// Neden Matérn 5/2?
//   RQ (Rational Quadratic) → pürüzsüz, sürekli türevli, uzun-mesafe korelasyon
//   Matérn 5/2 → iki kez türevlenebilir, sert geçişlere izin verir,
//   gerçek sensör/ölçüm serilerinde genellikle RQ'dan daha iyi uyum sağlar.
//   Periyodik örüntü yoksa Matérn standart seçimdir.
//
// GP posterior mean + posterior std'den örnekleme yapılır.
// Büyük n için O(n³) olan cholesky yerine inducing-point
// approximation (m=20 inducing point) kullanılır → O(m²n).
// ════════════════════════════════════════════════════════
function gpPredict(data, steps, set) {
  const n = data.length;

  // Matérn 5/2 kernel: k(r) = σ²(1 + √5·r/l + 5r²/3l²)·exp(-√5·r/l)
  const sigF = std(data);
  const ell  = Math.max(3, n * 0.15);  // length-scale: ~15% of series
  const sigN = sigF * 0.3;             // noise std

  function matern52(d) {
    const r = Math.abs(d) / ell;
    const s5r = Math.sqrt(5) * r;
    return sigF * sigF * (1 + s5r + 5*r*r/3) * Math.exp(-s5r);
  }

  // Inducing points: evenly spaced over [0, n+steps-1]
  const m   = Math.min(25, n);
  const Xu  = Array.from({length:m}, (_,i) => i * (n-1) / (m-1));
  const Xs  = Array.from({length:steps}, (_,i) => n + i); // test points
  const X   = Array.from({length:n}, (_,i) => i);         // training

  // Build K(Xu, Xu)
  const Kuu = Array.from({length:m}, (_,i) => Array.from({length:m}, (_,j) => matern52(Xu[i]-Xu[j]) + (i===j?1e-6:0)));
  // Build K(X, Xu)
  const Knu = Array.from({length:n}, (_,i) => Array.from({length:m}, (_,j) => matern52(X[i]-Xu[j])));
  // Build K(Xs, Xu)
  const Ksu = Array.from({length:steps}, (_,i) => Array.from({length:m}, (_,j) => matern52(Xs[i]-Xu[j])));

  // Cholesky of Kuu (small m×m)
  function chol(A) {
    const sz=A.length, L=Array.from({length:sz},()=>Array(sz).fill(0));
    for(let i=0;i<sz;i++){
      for(let j=0;j<=i;j++){
        let s=A[i][j];
        for(let k=0;k<j;k++) s-=L[i][k]*L[j][k];
        L[i][j]= i===j ? Math.sqrt(Math.max(s,1e-12)) : s/(L[j][j]||1e-12);
      }
    }
    return L;
  }
  function solveL(L,b){
    const n=L.length,x=Array(n).fill(0);
    for(let i=0;i<n;i++){let s=b[i];for(let j=0;j<i;j++)s-=L[i][j]*x[j];x[i]=s/L[i][i];}
    return x;
  }
  function solveLT(L,b){
    const n=L.length,x=Array(n).fill(0);
    for(let i=n-1;i>=0;i--){let s=b[i];for(let j=i+1;j<n;j++)s-=L[j][i]*x[j];x[i]=s/L[i][i];}
    return x;
  }
  function matVec(A,v){ return A.map(row=>row.reduce((s,a,j)=>s+a*v[j],0)); }

  const Luu = chol(Kuu);

  // Qnn = Knu @ Kuu⁻¹ @ Knu^T  (diagonal approx for efficiency → diag of Knn)
  // FITC-style diagonal noise: Λ = diag(knn - qnn) + σn²I
  // For posterior mean: μ* = Ksu @ Kuu⁻¹ @ Knu^T @ (Qnn + Λ)⁻¹ @ y
  // We use a simpler but numerically stable path:
  // α = (Knu @ Kuu⁻¹ @ Knu^T + σn²I)⁻¹ @ y  via CG-1 (direct solve for small n)

  // Compute W = Luu⁻¹ @ Knu^T  (m×n)
  const KnuT = Array.from({length:m}, (_,j) => Array.from({length:n}, (_,i) => Knu[i][j]));
  const W    = KnuT.map(col => solveL(Luu, col)); // m×n

  // Q = W^T @ W  = Knu @ Kuu⁻¹ @ Knu^T  (n×n, but we only need diagonal + solve)
  // For small n (≤200) do direct; else diagonal only
  const sn2 = sigN * sigN;

  // Posterior mean via (Q + sn2·I)⁻¹ @ y  using Woodbury:
  // (sn2·I + W^T W)⁻¹ = sn2⁻¹·I - sn2⁻²·W^T·(I + W·W^T/sn2)⁻¹·W
  const WWT = Array.from({length:m}, (_,i) => Array.from({length:m}, (_,j) => W[i].reduce((s,v,k)=>s+v*W[j][k],0)));
  const A   = WWT.map((row,i) => row.map((v,j) => v/sn2 + (i===j?1:0))); // I + WW^T/sn2
  const La  = chol(A);

  // α = sn2⁻¹ @ y - sn2⁻² @ W^T @ La⁻T @ La⁻¹ @ W @ y
  const Wy  = W.map(row => row.reduce((s,v,i)=>s+v*data[i],0)); // m-vec
  const v1  = solveL(La, Wy);
  const v2  = solveLT(La, v1);
  const Wv2 = Array.from({length:n}, (_,i) => W.reduce((s,row,j)=>s+row[i]*v2[j],0));
  const alpha= data.map((y,i) => y/sn2 - Wv2[i]/(sn2*sn2));

  // Posterior mean at test points: μ* = Ksu @ Kuu⁻¹ @ W @ alpha
  //                                   = Ksu @ Kuu⁻¹ @ Knu^T @ alpha
  // Ws = Luu⁻¹ @ Ksu^T  (m×steps)
  const KsuT = Array.from({length:m}, (_,j) => Array.from({length:steps}, (_,i) => Ksu[i][j]));
  const Ws   = KsuT.map(col => solveL(Luu, col)); // m×steps

  // KuuInv_Knu^T_alpha = Luu⁻T @ (Luu⁻¹ @ (Knu^T @ alpha))
  const KnuTalpha = Array.from({length:m}, (_,j) => n ? Knu.reduce((s,row,i)=>s+row[j]*alpha[i],0) : 0);
  const t1  = solveL(Luu, KnuTalpha);
  const t2  = solveLT(Luu, t1);  // Kuu⁻¹ @ Knu^T @ alpha

  // μ*[s] = Ksu[s,:] @ t2
  const muStar = Ksu.map(row => row.reduce((s,v,j)=>s+v*t2[j],0));

  // Posterior variance (diagonal): var*[s] = k(xs,xs) - Ws[:,s]^T @ Ws[:,s] + sn2
  const varStar = Array.from({length:steps}, (_,s) => {
    const diag = Ws.reduce((sum,row)=>sum+row[s]*row[s],0);
    return Math.max(sn2, sigF*sigF - diag + sn2);
  });

  // Sample one path from posterior + snap to set
  return muStar.map((mu, s) => {
    const sigma = Math.sqrt(varStar[s]);
    let v = mu + gaussRand() * sigma;
    if (set.length) v = snapToSet(v, set);
    return v;
  });
}

// ════════════════════════════════════════════════════════
// METHOD 7: PARTICLE FILTER (Sequential Monte Carlo)
//
// Adım kümesi kısıtlı seriler için teorik olarak en doğru
// yöntem. State uzayı modeli: non-linear, non-Gaussian.
//
// Model:
//   x_t = f(x_{t-1}) + noise   (geçiş)
//   y_t ∈ allowedSet            (ölçüm — diskrit)
//
// Partiküller durum uzayında dağılır, her gözlemde
// ağırlıklandırılır ve yeniden örneklenir (systematic
// resampling). Tahmin: ağırlıklı ortalama partiküller.
// ════════════════════════════════════════════════════════
function particlePredict(data, steps, set, nParticles=300) {
  const n   = data.length;
  const sN  = std(data);
  const a1v = acf1(data);
  const mn  = mean(data);
  const transNoise = sN * Math.max(0.05, 1 - Math.abs(a1v));

  // Gaussian likelihood P(y | x) for continuous; for discrete snap
  function logLik(obs, x) {
    const diff = obs - x;
    return -0.5 * (diff*diff) / (sN*sN*0.25 + 1e-10);
  }

  // --- Filter phase: estimate current hidden state ---
  // Init particles at data[0]
  let particles = Array.from({length:nParticles}, () => data[0] + gaussRand()*sN*0.3);
  let weights   = Array(nParticles).fill(1/nParticles);

  for (let t=1; t<n; t++) {
    // Propagate
    particles = particles.map(x => {
      const next = x * a1v + mn*(1-Math.abs(a1v)) + gaussRand()*transNoise;
      return next;
    });
    // Weight
    const logW = particles.map(x => logLik(data[t], x));
    const maxLW = Math.max(...logW);
    const rawW  = logW.map(lw => Math.exp(lw - maxLW));
    const sumW  = rawW.reduce((a,b)=>a+b,0);
    weights     = rawW.map(w => w/sumW);

    // Systematic resampling (every step for simplicity)
    const cumW = [];
    weights.reduce((c,w,i)=>{ cumW[i]=c+w; return cumW[i]; }, 0);
    const u0 = Math.random() / nParticles;
    const newP = [];
    let ci = 0;
    for (let k=0; k<nParticles; k++) {
      const target = u0 + k/nParticles;
      while (ci < nParticles-1 && cumW[ci] < target) ci++;
      newP.push(particles[ci] + gaussRand()*transNoise*0.1); // jitter
    }
    particles = newP;
    weights   = Array(nParticles).fill(1/nParticles);
  }

  // --- Predict phase: propagate particles forward ---
  const path = [];
  for (let s=0; s<steps; s++) {
    particles = particles.map(x => x * a1v + mn*(1-Math.abs(a1v)) + gaussRand()*transNoise);
    // Weighted median (equal weights here)
    const sorted = [...particles].sort((a,b)=>a-b);
    let v = sorted[Math.floor(nParticles/2)];
    if (set.length) v = snapToSet(v, set);
    path.push(v);
  }
  return path;
}

// ════════ ENSEMBLE ════════
function ensemblePredict(data,steps,set,T,phi,nStd){
  // 7 yöntem — her biri bir yol üretir
  const paths=[
    mcPredict(data,steps,set,T),
    arPredict(data,phi,steps,nStd*0.4,set),
    holtPredict(data,steps,set,nStd*0.4),
    nbWindowPredict(data,steps,set),
    kalmanPredict(data,steps,set,1),
    gpPredict(data,steps,set),
    particlePredict(data,steps,set,200),
  ];
  return Array.from({length:steps},(_,s)=>{
    const vals=paths.map(p=>p[s]);
    if(set.length){
      // Ağırlıklı çoğunluk oyu (tüm yöntemler eşit ağırlık)
      const freq={};
      vals.forEach(v=>{const k=v.toString();freq[k]=(freq[k]||0)+1;});
      return parseFloat(Object.entries(freq).sort((a,b)=>b[1]-a[1])[0][0]);
    }
    return mean(vals);
  });
}

// ════════ MAIN ════════
async function runAnalysis(){
  seriesData=parseSeries();
  if(seriesData.length<6){alert('En az 6 nokta gerekli');return;}

  const nPred=+document.getElementById('rN').value;
  const method=document.getElementById('method').value;
  const mcRep=+document.getElementById('rMC').value;
  const conf=+document.getElementById('bandConf').value;
  const alpha=(1-conf)/2;

  const bad=allowedSet.length
    ?seriesData.filter(v=>!allowedSet.some(s=>Math.abs(s-v)<1e-9)).length:0;

  const m=mean(seriesData),s=std(seriesData),a1=acf1(seriesData),tr=linTrend(seriesData);
  const effSet=allowedSet.length?allowedSet:[...new Set(seriesData)].sort((a,b)=>a-b);
  const ent=entropy(seriesData,effSet);

  document.getElementById('stLen').textContent=seriesData.length;
  document.getElementById('stSetN').textContent=allowedSet.length||'—';
  const bEl=document.getElementById('stBad');bEl.textContent=bad;bEl.className='si-val'+(bad>0?' err':'');
  document.getElementById('stMean').textContent=m.toFixed(3);
  document.getElementById('stStd').textContent=s.toFixed(3);
  document.getElementById('stAcf').textContent=a1.toFixed(3);
  document.getElementById('stEnt').textContent=ent.toFixed(2);
  const tEl=document.getElementById('stTrend');
  if(Math.abs(tr)<0.0005){tEl.textContent='→ Sabit';tEl.className='si-val';}
  else if(tr>0){tEl.textContent='↑ Yükselen';tEl.className='si-val ok';}
  else{tEl.textContent='↓ Düşen';tEl.className='si-val err';}

  document.getElementById('progWrap').style.display='block';
  document.getElementById('resultsArea').style.display='none';
  setP(5,'Modeller hazırlanıyor…');await sleep(20);

  const T=buildTrans(seriesData,effSet);
  const phi=fitAR(seriesData,Math.min(6,Math.floor(seriesData.length*0.3)));
  const nStd=s*Math.max(0.05,1-Math.abs(a1));

  setP(12,'Simülasyonlar çalışıyor…');await sleep(10);

  const simPaths=[];
  const bSz=100;
  for(let i=0;i<mcRep;i+=bSz){
    const nb=Math.min(bSz,mcRep-i);
    for(let b=0;b<nb;b++){
      let path;
      if(method==='mc')        path=mcPredict(seriesData,nPred,effSet,T);
      else if(method==='arima')path=arPredict(seriesData,phi,nPred,nStd*0.4,effSet);
      else if(method==='holt') path=holtPredict(seriesData,nPred,effSet,nStd*0.4);
      else if(method==='nbwin')path=nbWindowPredict(seriesData,nPred,effSet);
      else if(method==='kalman')  path=kalmanPredict(seriesData,nPred,effSet,1);
      else if(method==='gp')      path=gpPredict(seriesData,nPred,effSet);
      else if(method==='particle')path=particlePredict(seriesData,nPred,effSet,150);
      else                     path=ensemblePredict(seriesData,nPred,effSet,T,phi,nStd);
      simPaths.push(path);
    }
    setP(12+((i+bSz)/mcRep)*72,`Simülasyon: ${Math.min(i+bSz,mcRep)}/${mcRep}`);
    await sleep(0);
  }

  setP(86,'Olasılıklar hesaplanıyor…');await sleep(10);

  const predMed=[],predLo=[],predHi=[];
  for(let st=0;st<nPred;st++){
    const vals=simPaths.map(p=>p[st]);
    predMed.push(pct(vals,.5));predLo.push(pct(vals,alpha));predHi.push(pct(vals,1-alpha));
  }

  // 2D prob table: prob2d[step][setIdx]
  const prob2d=Array.from({length:nPred},(_,step)=>{
    const vals=simPaths.map(p=>p[step]);
    const cnt={}; effSet.forEach(v=>{cnt[v]=0;});
    vals.forEach(v=>{const k=snapToSet(v,effSet);cnt[k]=(cnt[k]||0)+1;});
    return effSet.map(v=>(cnt[v]||0)/vals.length);
  });

  setP(94,'Grafik çiziliyor…');await sleep(10);
  drawChart(predMed,predLo,predHi,bad);
  showResults(predMed,predLo,predHi,nPred,bad,m,s,a1,tr,method,mcRep,conf,prob2d,effSet,ent);
  setP(100,'Tamamlandı ✔','100%');
  document.getElementById('resultsArea').style.display='block';
}

// ════════ CHART ════════
function drawChart(predMed,predLo,predHi,bad){
  if(mainChart)mainChart.destroy();
  const ctx=document.getElementById('mainChart').getContext('2d');
  const oLen=seriesData.length;
  const labels=Array.from({length:oLen+predMed.length},(_,i)=>i);
  const obsSeries=[...seriesData,...Array(predMed.length).fill(null)];
  const pMedS=[...Array(oLen-1).fill(null),seriesData[oLen-1],...predMed];
  const pLoS =[...Array(oLen-1).fill(null),seriesData[oLen-1],...predLo];
  const pHiS =[...Array(oLen-1).fill(null),seriesData[oLen-1],...predHi];
  const invS=allowedSet.length
    ?seriesData.map((v,i)=>allowedSet.some(s=>Math.abs(s-v)<1e-9)?null:v)
    :seriesData.map(()=>null);

  mainChart=new Chart(ctx,{
    type:'line',
    data:{labels,datasets:[
      {label:'Band Hi',data:pHiS,borderColor:'transparent',backgroundColor:'rgba(31,122,69,.10)',pointRadius:0,fill:'+1',tension:.35},
      {label:'Band Lo',data:pLoS,borderColor:'rgba(31,122,69,.25)',borderWidth:1,borderDash:[3,2],backgroundColor:'rgba(31,122,69,.10)',pointRadius:0,fill:false,tension:.35},
      {label:'Median',data:pMedS,borderColor:'#1f7a45',borderWidth:2.5,borderDash:[6,3],pointRadius:0,fill:false,tension:.35},
      {label:'Gözlem',data:obsSeries,borderColor:'#1a5c8a',borderWidth:2,pointRadius:2.5,pointBackgroundColor:'#1a5c8a',fill:false,tension:.2},
      {label:'Geçersiz',type:'scatter',data:[...invS,...Array(predMed.length).fill(null)],
       backgroundColor:'rgba(184,50,50,.75)',borderColor:'transparent',pointRadius:5,pointStyle:'crossRot',fill:false}
    ]},
    options:{
      animation:false,responsive:true,maintainAspectRatio:false,
      plugins:{legend:{display:false},
        tooltip:{mode:'index',intersect:false,callbacks:{label:c=>`${c.dataset.label}: ${c.parsed.y!=null?c.parsed.y.toFixed(4):''}`}},
        zoom:{pan:{enabled:true,mode:'x'},zoom:{wheel:{enabled:true},pinch:{enabled:true},mode:'x'}}
      },
      scales:{
        x:{grid:{color:'rgba(0,0,0,0.04)'},ticks:{color:'#6e6050',font:{family:'Space Mono',size:9},maxTicksLimit:14},
           title:{display:true,text:'Adım',color:'#6e6050',font:{family:'Space Mono',size:9}}},
        y:{grid:{color:'rgba(0,0,0,0.04)'},ticks:{color:'#6e6050',font:{family:'Space Mono',size:9},maxTicksLimit:8}}
      },
      elements:{point:{radius:0}}
    }
  });
}
function zoomIn(){if(mainChart)mainChart.zoom(1.35);}
function zoomOut(){if(mainChart)mainChart.zoom(0.75);}
function resetZoom(){if(mainChart)mainChart.resetZoom();}
function toggleFS(){
  const c=document.getElementById('chartCard'),isFs=c.classList.toggle('fullscreen');
  document.getElementById('fsBtn').textContent=isFs?'✕':'⛶';
  setTimeout(()=>{if(mainChart)mainChart.resize();},50);
}
document.addEventListener('keydown',e=>{
  if(e.key==='Escape'){
    const c=document.getElementById('chartCard');
    if(c.classList.contains('fullscreen')){
      c.classList.remove('fullscreen');
      document.getElementById('fsBtn').textContent='⛶';
      setTimeout(()=>{if(mainChart)mainChart.resize();},50);
    }
  }
});

// ════════ 2D PROBABILITY TABLE ════════
function render2DTable(prob2d,effSet,nPred){
  // column max for colour normalisation
  const colMax=effSet.map((_,ci)=>Math.max(...prob2d.map(row=>row[ci]),0.001));

  const header=`<tr>
    <th class="rh" style="min-width:70px;">Adım ↓</th>
    ${effSet.map(v=>`<th>${v}</th>`).join('')}
    <th class="rh">En Olası</th>
    <th class="rh">2. Olası</th>
  </tr>`;

  const rows=prob2d.map((row,step)=>{
    const maxP=Math.max(...row);
    // top-2 indices
    const ranked=[...row.map((p,i)=>({p,i}))].sort((a,b)=>b.p-a.p);
    const best=ranked[0],second=ranked[1];

    const cells=row.map((p,ci)=>{
      const pct=(p*100).toFixed(1);
      const norm=p/colMax[ci];
      // blue heat
      const r=Math.round(250-norm*110);
      const g=Math.round(248-norm*100);
      const b=Math.round(255-norm*30);
      const bg=`rgb(${r},${g},${b})`;
      const txt=norm>0.6?'#fff':'var(--ink)';
      const cls=(ci===best.i?'best':'')+(p===maxP?' best':'');
      return `<td style="background:${bg};color:${txt}" class="${ci===best.i?'best':''}">${pct}%</td>`;
    }).join('');

    return `<tr>
      <td class="step-hdr">t+${step+1}</td>
      ${cells}
      <td class="best-txt">${effSet[best.i]} <span style="font-size:10px;opacity:.7">(${(best.p*100).toFixed(1)}%)</span></td>
      <td style="color:var(--amber);font-weight:700;">${effSet[second.i]} <span style="font-size:10px;opacity:.7">(${(second.p*100).toFixed(1)}%)</span></td>
    </tr>`;
  }).join('');

  document.getElementById('prob2dWrap').innerHTML=`
    <table class="prob2d"><thead>${header}</thead><tbody>${rows}</tbody></table>
    <div style="font-size:10px;color:var(--ink3);margin-top:8px;line-height:1.7;">
      Koyu mavi hücre = o sütundaki en yüksek görülme oranı &nbsp;·&nbsp;
      Yeşil çerçeve = satır başına en olası değer &nbsp;·&nbsp;
      Renk sütun içi normalize edilmiştir
    </div>`;
}

// ════════ SHOW RESULTS ════════
function showResults(predMed,predLo,predHi,nPred,bad,m,s,a1,tr,method,mcRep,conf,prob2d,effSet,ent){
  const last=seriesData[seriesData.length-1];
  const fMed=predMed[nPred-1],fLo=predLo[nPred-1],fHi=predHi[nPred-1];
  const spread=fHi-fLo;
  const acfI=Math.abs(a1)>0.5?'Güçlü':Math.abs(a1)>0.2?'Orta':'Zayıf';
  const freq={};seriesData.forEach(v=>{const k=v.toString();freq[k]=(freq[k]||0)+1;});
  const top=Object.entries(freq).sort((a,b)=>b[1]-a[1])[0];
  const names={mc:'MC Markov',arima:'ARIMA AR(p)',holt:'Holt ES',nbwin:'Naive Bayes',kalman:'Kalman Filter',gp:'Gaussian Process',particle:'Particle Filter',combined:'Ensemble (7 Yöntem)'};

  document.getElementById('findings').innerHTML=`
    <div class="fr"><span class="fr-l">En sık değer</span><span class="fr-r ok">${top[0]} (%${((top[1]/seriesData.length)*100).toFixed(1)})</span></div>
    <div class="fr"><span class="fr-l">ACF(1)</span><span class="fr-r ${Math.abs(a1)>0.3?'ok':'warn'}">${a1.toFixed(4)} — ${acfI} otokor.</span></div>
    <div class="fr"><span class="fr-l">Entropi</span><span class="fr-r ${ent>2?'warn':''}">${ent.toFixed(3)} / ${(Math.log2(effSet.length||1)).toFixed(2)} bit max</span></div>
    <div class="fr"><span class="fr-l">Trend</span><span class="fr-r">${tr.toFixed(5)}/adım</span></div>
    <div class="fr"><span class="fr-l">Geçersiz nokta</span><span class="fr-r ${bad>0?'err':''}">${bad}${bad>0?' ⚠':''}</span></div>
    <div class="fr"><span class="fr-l">Yöntem</span><span class="fr-r">${names[method]||method} · ${mcRep.toLocaleString()} sim</span></div>`;

  document.getElementById('predSummary').innerHTML=`
    <div class="fr"><span class="fr-l">Son gözlem</span><span class="fr-r">${last}</span></div>
    <div class="fr"><span class="fr-l">t+${nPred} median</span><span class="fr-r ok">${fMed}</span></div>
    <div class="fr"><span class="fr-l">Alt band (%${(conf*100).toFixed(0)})</span><span class="fr-r warn">${fLo}</span></div>
    <div class="fr"><span class="fr-l">Üst band (%${(conf*100).toFixed(0)})</span><span class="fr-r warn">${fHi}</span></div>
    <div class="fr"><span class="fr-l">Yön</span><span class="fr-r ${fMed>last?'ok':fMed<last?'err':''}">${fMed>last?'↑ Yükselen':fMed<last?'↓ Düşen':'→ Sabit'}</span></div>
    <div class="fr"><span class="fr-l">Belirsizlik ±</span><span class="fr-r">${(spread/2).toFixed(4)}</span></div>`;

  render2DTable(prob2d,effSet,nPred);

  const bestM=Math.abs(a1)>0.6?'Kalman Filter (güçlü otokorelasyon + gürültü modeli)':
              Math.abs(a1)>0.4?'MC Markov (güçlü geçiş örüntüsü)':
              ent<0.8?'Naive Bayes (düşük entropi, düzenli seri)':
              ent>2.5?'Particle Filter (yüksek belirsizlik, non-linear)':
              'Ensemble (7 Yöntem)';
  document.getElementById('infoBox').innerHTML=`
    <strong>7 Yöntem Açıklaması:</strong><br><br>
    <b>1. MC Markov Zinciri</b> — geçiş olasılık matrisi; hangi değerden sonra hangi değer kaç kez geldi?<br>
    <b>2. ARIMA AR(p)</b> — Yule-Walker otoregresif katsayılar; son p gözleme göre doğrusal tahmin.<br>
    <b>3. Holt Exp. Smoothing</b> — α=0.3 seviye + β=0.1 trend; yavaş değişen serilerde kararlı.<br>
    <b>4. Naive Bayes (Pencere)</b> — son 3 değerin "bağlamı" → sonraki değer dağılımı.<br>
    <b>5. Kalman Filter</b> — [seviye, trend] gizli durum takibi. EM-lite ile R (ölçüm) ve Q (süreç)
       gürültüsü veriden otomatik tahmin edilir. Gürültülü ama otokorele serilerde en güçlü.<br>
    <b>6. Gaussian Process (Matérn 5/2)</b> — kernel tabanlı Bayesian regresyon.
       Matérn 5/2 seçildi çünkü: RQ/SE kerneller aşırı pürüzsüz; Matérn 5/2 iki kez türevlenebilir
       ama ani geçişlere izin verir — sensör/ölçüm serilerine en uygun kernel.
       Büyük n için inducing-point (FITC) yaklaşımı kullanılır → O(m²n) karmaşıklık.<br>
    <b>7. Particle Filter (SMC)</b> — Sequential Monte Carlo. Non-linear, non-Gaussian durum uzayı modeli.
       ${set.length?'Adım kümesi kısıtlı seriler için teorik olarak en doğru yöntem.':'Genel non-parametrik tahmin.'}
       Sistemik yeniden örnekleme ile parçacık dejenerasyonu önlenir.<br><br>
    Entropi = <strong>${ent.toFixed(3)} bit</strong> →
    ${ent<0.5?'çok düzenli, tahmin kolay':ent<1.5?'orta belirsizlik':ent<2.5?'yüksek belirsizlik':'çok belirsiz, tahmin güç'}.&nbsp;
    Önerilen: <strong>${bestM}</strong>.
    ${bad>0?`<br><span style="color:var(--red)">⚠ ${bad} nokta adım kümesi dışında.</span>`:''}`;


// ════════ EXAMPLE ════════
function loadExample(){
  document.getElementById('setInput').value='3, 3.2, 3.4, 3.6';
  parseSetInput();
  document.getElementById('seriesInput').value=
    '3,3,3.2,3.2,3.4,3.4,3.4,3.2,3.2,3,3,3,3.2,3.4,3.6,3.6,3.4,3.4,3.2,3.2,'+
    '3,3,3.2,3.2,3.4,3.4,3.6,3.6,3.4,3.2,3,3,3.2,3.4,3.4,3.2,3.2,3,3,3.2';
  document.getElementById('rN').value=8; document.getElementById('vN').textContent='8';
  document.getElementById('method').value='combined';
}
</script>
</body>
</html>
